# -*- coding: utf-8 -*-
"""Programming _For_DataAnalysis_Assessment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18RGuXyyrrMRf7B8bR_KRez9eRP3ghBqJ

### **Mounting the google drive to the colab environment:**
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd '/content/drive/MyDrive/Assessment_Final_Data'

"""# TASK 1: DATA HANDLING

## LOADING THE DATASET
"""

# Commented out IPython magic to ensure Python compatibility.
# %ls

import pandas as pd
import glob

# Get all CSV files in the folder
csv_files = glob.glob("/content/drive/MyDrive/Assessment_Final_Data/*.csv")
csv_files

"""## COMBINING ALL THE DATASETS TO ONE DATAFRAME"""

# Read and combine all CSV files
combined_df = pd.concat([pd.read_csv(file) for file in csv_files], ignore_index=True)
combined_df

df1 = combined_df.drop_duplicates()
df1

# Save to a new CSV file
df1.to_csv("combined_output.csv", index=False)

print("All CSV files have been merged into 'combined_output.csv'.")

"""# TASK2 : EDA(EXPLORATORY DATA ANALYSIS)

## A) FUNDAMENTAL DATA UNDERSTANDING
"""

df1.shape

df1.columns

df1.info()

selected_columns = ['No', 'year', 'month', 'day', 'hour', 'PM2.5', 'PM10', 'SO2', 'NO2','CO', 'O3', 'TEMP', 'PRES', 'DEWP', 'RAIN', 'wd', 'WSPM', 'station']
df = df1[selected_columns]
df

# Missing values
def missing_values_table(df):
        # Total missing values
        mis_val = df.isnull().sum()

        # Percentage of missing values
        mis_val_percent = 100 * df.isnull().sum() / len(df)

        # Make a table with the results
        mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1)
        print(mis_val_table)

        # Rename the columns
        mis_val_table_ren_columns = mis_val_table.rename(
        columns = {0 : 'Missing Values', 1 : '% of Total Values'})

        # Sort the table by percentage of missing descending
        mis_val_table_ren_columns = mis_val_table_ren_columns.sort_values(
        '% of Total Values', ascending=False)

        # Return the dataframe with missing information
        return mis_val_table_ren_columns

missing_values= missing_values_table(df)
missing_values.style.background_gradient(cmap='RdYlGn_r')

df.describe()

df.isnull().sum()

"""# Finding Out Outliers Using IQR(INTER QUARTILE RANGE) Method one of the common method used to find outliers in skewed data."""

# Choose your column (e.g., 'PM2.5')
column = 'CO'

Q1 = df['CO'].quantile(0.25)
Q3 = df['CO'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['CO'] < lower_bound) | (df['CO'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'CO'}:", outliers.shape[0])
print(outliers[['CO']])

# Choose your column (e.g., 'PM2.5')
column = 'O3'

Q1 = df['O3'].quantile(0.25)
Q3 = df['O3'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['O3'] < lower_bound) | (df['O3'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'O3'}:", outliers.shape[0])
print(outliers[['O3']])

# Choose your column (e.g., 'PM2.5')
column = 'NO2'

Q1 = df['NO2'].quantile(0.25)
Q3 = df['NO2'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['NO2'] < lower_bound) | (df['NO2'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'NO2'}:", outliers.shape[0])
print(outliers[['NO2']])

# Choose your column (e.g., 'PM2.5')
column = 'SO2'

Q1 = df['SO2'].quantile(0.25)
Q3 = df['SO2'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['SO2'] < lower_bound) | (df['SO2'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'SO2'}:", outliers.shape[0])
print(outliers[['SO2']])

# Choose your column (e.g., 'PM2.5')
column = 'PM2.5'

Q1 = df['PM2.5'].quantile(0.25)
Q3 = df['PM2.5'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['PM2.5'] < lower_bound) | (df['PM2.5'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'PM2.5'}:", outliers.shape[0])
print(outliers[['PM2.5']])

# Choose your column (e.g., 'PM2.5')
column = 'PM10'

Q1 = df['PM10'].quantile(0.25)
Q3 = df['PM10'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['PM10'] < lower_bound) | (df['PM10'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'PM10'}:", outliers.shape[0])
print(outliers[['PM10']])

# Choose your column (e.g., 'PM2.5')
column = 'TEMP'

Q1 = df['TEMP'].quantile(0.25)
Q3 = df['TEMP'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['TEMP'] < lower_bound) | (df['TEMP'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'TEMP'}:", outliers.shape[0])

# Choose your column (e.g., 'PM2.5')
column = 'PRES'

Q1 = df['PRES'].quantile(0.25)
Q3 = df['PRES'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['PRES'] < lower_bound) | (df['PRES'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'PRES'}:", outliers.shape[0])

# Choose your column (e.g., 'PM2.5')
column = 'DEWP'

Q1 = df['DEWP'].quantile(0.25)
Q3 = df['DEWP'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['DEWP'] < lower_bound) | (df['DEWP'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'DEWP'}:", outliers.shape[0])

# Choose your column (e.g., 'PM2.5')
column = 'RAIN'

Q1 = df['RAIN'].quantile(0.25)
Q3 = df['RAIN'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['RAIN'] < lower_bound) | (df['RAIN'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'RAIN'}:", outliers.shape[0])
print(outliers[['RAIN']])

# Choose your column (e.g., 'PM2.5')
column = 'WSPM'

Q1 = df['WSPM'].quantile(0.25)
Q3 = df['WSPM'].quantile(0.75)
IQR = Q3 - Q1

# Define outlier bounds
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filter out the outliers
outliers = df[(df['WSPM'] < lower_bound) | (df['WSPM'] > upper_bound)]

# Display outliers
print(f"Number of outliers in {'WSPM'}:", outliers.shape[0])
print(outliers[['WSPM']])

import pandas as pd

# Fill missing values in 'CO' with the median because it has outliers in that data
df['CO'].fillna(df['CO'].median(), inplace=True)

# Fill missing values in 'O3' with the median because it has outliers in that data
df['O3'].fillna(df['O3'].median(), inplace=True)

# Fill missing values in 'NO2' with the median because it has outliers in that data
df['NO2'].fillna(df['NO2'].median(), inplace=True)

# Fill missing values in 'SO2' with the median because it has outliers in that data
df['SO2'].fillna(df['SO2'].median(), inplace=True)

# Fill missing values in 'PM2.5' with the median because it has outliers in that data
df['PM2.5'].fillna(df['PM2.5'].median(), inplace=True)

# Fill missing values in 'PM10' with the median because it has outliers in that data
df['PM10'].fillna(df['PM10'].median(), inplace=True)

# Fill missing values in 'RAIN' with the median because it has outliers in that data
df['RAIN'].fillna(df['RAIN'].median(), inplace=True)

# Fill missing values in 'WSPM' with the median because it has outliers in that data
df['WSPM'].fillna(df['WSPM'].median(), inplace=True)

# Fill missing values in 'TEMP' with the mean beacuse it doesn't have any outliers
df['TEMP'].fillna(df['TEMP'].mean(), inplace=True)

# Fill missing values in 'PRES' with the mean beacuse it doesn.t have any outliers
df['PRES'].fillna(df['PRES'].mean(), inplace=True)

# Fill missing values in 'DEWP' with the mean because it doesn't have any outliers
df['DEWP'].fillna(df['DEWP'].mean(), inplace=True)

# Fill missing values in 'wd' with the mode (most common value) because it is a categorical column
df['wd'].fillna(df['wd'].mode()[0], inplace=True)


# Verify that all missing values have been filled
print(df.isnull().sum())

print(df.isnull().sum())

df['solid_pollutants'] = df[['PM2.5', 'PM10']].sum(axis=1, skipna=True)
df['solid_pollutants']

df['gas_pollutants'] = df[['SO2', 'NO2', 'CO', 'O3']].sum(axis=1, skipna=True)
df['gas_pollutants']

print(df.columns)

df = df.drop('z_score', axis=1)

print(df.columns)

# Combine date parts into a datetime column
df['datetime'] = pd.to_datetime(df[['year', 'month', 'day', 'hour']])
df['datetime']

# Extract features from datetime
df['dayofweek'] = df['datetime'].dt.dayofweek       # Monday = 0
df['dayofweek']

df['is_weekend'] = df['dayofweek'].apply(lambda x: 1 if x >= 5 else 0)
df['is_weekend']

df['temp_dewp_diff'] = df['TEMP'] - df['DEWP']
df = df.sort_values(by='temp_dewp_diff', ascending=False).reset_index(drop=True) #Larger Difference results In Lower Humidity
df

df.info()

df.describe().T

"""## Insights Which we got from the summary statistics:

1.This dataset shows that timeline is from 03/01/2013 to 02/28/2017 based on the minimum and maximum dates as well as mean implies that it is 03/01/2015

2.Solid Pollutants which include PM2.5 and PM10

a)PM2.5 which has Mean of 78.7 µg/m³ whereas PM10 which has a Mean of 102 µg/m³ both of them has an maximum of 999 which is closer to 1000 that means it is extremely high pollution causing pollutants.

3.Gas Pollutants which include SO2,NO2,CO,O3 each of them also have an huge impact on airpollution

a)CO(Carbon Monoxide):which has highest mean of over 1202 µg/m³ and with the highest range of 10000.0 µg/m³ shows that severe air pollution causing by this gas.

b)O3(Ozone): which has a mean of 56.5 µg/m³ and with the highest value ranging at 674 µg/m³.

c)NO2(Nitrogen Dioxide):which has a mean of 48.9 µg/m³ with the highest value as 264 µg/m³ which might result in acid rains as well.

d)SO2(Sulfur Dioxide) which has a mean of 14.85 µg/m³ with the highest value as 411 µg/m³ might impact on climate changes.




"""



















